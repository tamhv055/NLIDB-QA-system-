<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_05) on Wed May 28 12:10:37 CEST 2014 -->
<title>Query</title>
<meta name="date" content="2014-05-28">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Query";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../jpl/PrologException.html" title="class in jpl"><span class="strong">Prev Class</span></a></li>
<li><a href="../jpl/Term.html" title="class in jpl"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?jpl/Query.html" target="_top">Frames</a></li>
<li><a href="Query.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jpl</div>
<h2 title="Class Query" class="title">Class Query</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>jpl.Query</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.util.Enumeration</dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Query</span>
extends java.lang.Object
implements java.util.Enumeration</pre>
<div class="block">A Query instance is created by an application in order to query the Prolog database
 (or to invoke a built-in predicate).
 It is initialised with a
 Compound (or Atom) denoting the goal which is to be called, and also contains assorted private state
 relating to solutions.  In some future version, it may contain details of the module
 in which the goal is to be called.<p>
 A Query is either open or closed: when closed, it has no connection to the Prolog system;
 when open, it is linked to an active goal within a Prolog engine.<p>
 The Query class implements the Enumeration interface,
 through which one can obtain successive solutions.  The Enumeration
 hasMoreElements() method returns true if the call or redo succeeded (otherwise
 false), and if the call or redo did succeed, the nextElement() method returns
 a Hashtable representing variable bindings; the elements in the
 Hashtable are Terms, indexed by the (String) names of the Variables with which they are associated.
 For example, if <i>p(a)</i> and <i>p(b)</i> are facts in the Prolog
 database, then the following is equivalent to printing all
 the solutions to the Prolog query <i>p(X)</i>:
 <pre>
 Variable X = new Variable("X");
 Term arg[] = { X };
 Query    q = new Query("p", arg);
 
 while (q.hasMoreElements()){
     Term bound_to_x = ((Hashtable) q.nextElement()).get("X");
     System.out.println(bound_to_x);
 }
 </pre>
 Make sure to close the Query (using the close() method) if you do not need
 any further solutions which it may have.
 It is safe (although redundant) to close a Query whose solutions are already exhausted,
 or which is already closed.
 
 To obtain just one solution from a Query, use the oneSolution() method.
 
 To obtain all solutions, use the allSolutions() method.
 
 To obtain at most N solutions, use the nSolutions() method.
 
 To determine merely whether the Query is provable,
 use the hasSolution() method
 (i.e. has at least one solution).
 <hr>
 <i>
 Copyright (C) 2007  Paul Singleton<p>
 Copyright (C) 1998  Fred Dushin
 <p>
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
 <p>
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Library Public License for more details.<p>
 </i>
 <hr></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../jpl/Query.html#Query(java.lang.String)">Query</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This constructor builds a Query from the given Prolog source text.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../jpl/Query.html#Query(java.lang.String, jpl.Term)">Query</a></strong>(java.lang.String&nbsp;text,
     <a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;arg)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../jpl/Query.html#Query(java.lang.String, jpl.Term[])">Query</a></strong>(java.lang.String&nbsp;text,
     <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;args)</code>
<div class="block">If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query (?) symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../jpl/Query.html#Query(jpl.Term)">Query</a></strong>(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;t)</code>
<div class="block">This constructor creates a Query whose goal is the specified Term.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#abort()">abort</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#allSolutions()">allSolutions</a></strong>()</code>
<div class="block">calls the Query's goal to exhaustion
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#allSolutions(java.lang.String)">allSolutions</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#allSolutions(java.lang.String, jpl.Term[])">allSolutions</a></strong>(java.lang.String&nbsp;text,
            <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#allSolutions(jpl.Term)">allSolutions</a></strong>(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query whose goal is the given Term,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../jpl/Term.html" title="class in jpl">Term</a>[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#args()">args</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Use .goal().args() instead.</i></div>
</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#close()">close</a></strong>()</code>
<div class="block">This method can be used to close an open query before its solutions are exhausted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#debugString()">debugString</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#getSolution()">getSolution</a></strong>()</code>
<div class="block">This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#getSubstWithNameVars()">getSubstWithNameVars</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../jpl/Compound.html" title="class in jpl">Compound</a></code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#goal()">goal</a></strong>()</code>
<div class="block">Returns the Compound (hence perhaps an Atom) which is the goal of this Query</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasMoreElements()">hasMoreElements</a></strong>()</code>
<div class="block">This method implements part of the java.util.Enumeration
 interface.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasMoreSolutions()">hasMoreSolutions</a></strong>()</code>
<div class="block">This method returns true if JPL was able to initiate a "call" of this
 Query within a Prolog engine.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasSolution()">hasSolution</a></strong>()</code>
<div class="block">This method will attempt to call this Query's goal within an available Prolog engine.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasSolution(java.lang.String)">hasSolution</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text
 and calls it at most once, returning true if a solution was found, else false.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasSolution(java.lang.String, jpl.Term[])">hasSolution</a></strong>(java.lang.String&nbsp;text,
           <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its corresponding arg
 to provide the new Query's goal: the resulting Query is called as described above.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#hasSolution(jpl.Term)">hasSolution</a></strong>(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning true if a solution was found, else false.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#isOpen()">isOpen</a></strong>()</code>
<div class="block">isOpen() returns true iff the query is open.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#name()">name</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Use .goal().name() instead.</i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nextElement()">nextElement</a></strong>()</code>
<div class="block">This method implements part of the java.util.Enumeration
 interface.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nextSolution()">nextSolution</a></strong>()</code>
<div class="block">This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nSolutions(long)">nSolutions</a></strong>(long&nbsp;n)</code>
<div class="block">calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nSolutions(java.lang.String, long)">nSolutions</a></strong>(java.lang.String&nbsp;text,
          long&nbsp;n)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nSolutions(java.lang.String, jpl.Term[], long)">nSolutions</a></strong>(java.lang.String&nbsp;text,
          <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params,
          long&nbsp;n)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable[]</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#nSolutions(jpl.Term, long)">nSolutions</a></strong>(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal,
          long&nbsp;n)</code>
<div class="block">This static method creates a Query whose goal is the given Term,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#oneSolution()">oneSolution</a></strong>()</code>
<div class="block">Returns the first solution, if any, as a (possibly empty) Hashtable of variablename-to-term bindings, else null.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#oneSolution(java.lang.String)">oneSolution</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#oneSolution(java.lang.String, jpl.Term[])">oneSolution</a></strong>(java.lang.String&nbsp;text,
           <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its respective param
 to provide the goal of this query:
 the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Hashtable, else null.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Hashtable</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#oneSolution(jpl.Term)">oneSolution</a></strong>(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#open()">open</a></strong>()</code>
<div class="block">This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#query()">query</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Use .hasSolution() instead.</i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#rewind()">rewind</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../jpl/Query.html#toString()">toString</a></strong>()</code>
<div class="block">Returns a crude String representation of a Query.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Query(jpl.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;t)</pre>
<div class="block">This constructor creates a Query whose goal is the specified Term.
 The Query is initially closed.
 <b>NB</b>  Creating an instance of the Query class does not
 result in a call to a Prolog engine.
 <b>NB</b>  The goal can be a Compound or an Atom (Atom extends Compound), but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>t</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="Query(java.lang.String, jpl.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text,
     <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;args)</pre>
<div class="block">If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query (?) symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the name of the principal functor of this Query's goal</dd><dd><code>args</code> - the arguments of this Query's goal</dd></dl>
</li>
</ul>
<a name="Query(java.lang.String, jpl.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text,
     <a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;arg)</pre>
</li>
</ul>
<a name="Query(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text)</pre>
<div class="block">This constructor builds a Query from the given Prolog source text.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of this Query</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="name()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>name</h4>
<pre>public final&nbsp;java.lang.String&nbsp;name()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Use .goal().name() instead.</i></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the name of this Query's goal (redundant, deprecated)</dd></dl>
</li>
</ul>
<a name="args()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>args</h4>
<pre>public final&nbsp;<a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;args()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Use .goal().args() instead.</i></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the arguments of this Query's goal (redundant, deprecated)</dd></dl>
</li>
</ul>
<a name="goal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goal</h4>
<pre>public final&nbsp;<a href="../jpl/Compound.html" title="class in jpl">Compound</a>&nbsp;goal()</pre>
<div class="block">Returns the Compound (hence perhaps an Atom) which is the goal of this Query</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a Term representing the goal of this Query</dd></dl>
</li>
</ul>
<a name="isOpen()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOpen</h4>
<pre>public final&nbsp;boolean&nbsp;isOpen()</pre>
<div class="block">isOpen() returns true iff the query is open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if the query is open, otherwise false.</dd></dl>
</li>
</ul>
<a name="hasMoreSolutions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMoreSolutions</h4>
<pre>public final&nbsp;boolean&nbsp;hasMoreSolutions()</pre>
<div class="block">This method returns true if JPL was able to initiate a "call" of this
 Query within a Prolog engine.  It is designed to be used
 with the nextSolution() method to retrieve one or
 more substitutions in the form of Hashtables.  To iterate through
 all the solutions to a Query, for example, one might write
 <pre>
 Query q = // obtain Query reference
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // process solution...
 }
 </pre>
 To ensure thread-safety, you should wrap sequential calls to
 this method in a synchronized block, using the static
 lock method to obtain the monitor.
 <pre>
 Query q = // obtain Query reference
 synchronized ( jpl.Query.lock() ){
     while ( q.hasMoreElements() ){
          Hashtable solution = q.nextSolution();
          // process solution...
     }
 }
 </pre></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if the Prolog query succeeds; otherwise false.</dd></dl>
</li>
</ul>
<a name="open()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>open</h4>
<pre>public final&nbsp;void&nbsp;open()</pre>
<div class="block">This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.  It is designed to be used
 with the getSolution() and close() methods to retrieve one or
 more substitutions in the form of Hashtables.
 <pre>
 Query q = // obtain Query reference
 Hashtable soln;
 q.open();
 while ((soln = q.getSolution()) != null) {
      // process solution...
 }
 </pre>
 <p>
 If this method is called on an already-open Query,
 or if the query cannot be set up for whatever reason,
 then a JPLException will be thrown.</div>
</li>
</ul>
<a name="getSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolution</h4>
<pre>public final&nbsp;java.util.Hashtable&nbsp;getSolution()</pre>
<div class="block">This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named "X", one can obtain the Term bound to "X" in the solution
 by looking up "X" in the Hashtable.
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that the Query is no longer open.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, for a given Query
 instance.
 </menu>
 
 This method will throw a JPLException if Query is not open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A Hashtable representing a substitution, or null</dd></dl>
</li>
</ul>
<a name="getSubstWithNameVars()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubstWithNameVars</h4>
<pre>public final&nbsp;java.util.Hashtable&nbsp;getSubstWithNameVars()</pre>
</li>
</ul>
<a name="nextSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextSolution</h4>
<pre>public final&nbsp;java.util.Hashtable&nbsp;nextSolution()</pre>
<div class="block">This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named "X", one can obtain the Term bound to "X" in the solution
 by looking up "X" in the Hashtable.
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that the Query is no longer open.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, for a given Query
 instance.
 </menu>
 
 This method will throw a JPLException if Query is not open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A Hashtable representing a substitution.</dd></dl>
</li>
</ul>
<a name="hasMoreElements()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMoreElements</h4>
<pre>public final&nbsp;boolean&nbsp;hasMoreElements()</pre>
<div class="block">This method implements part of the java.util.Enumeration
 interface.  It is a wrapper for hasMoreSolutions.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>hasMoreElements</code>&nbsp;in interface&nbsp;<code>java.util.Enumeration</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>true if the Prolog query yields a (or another) solution, else false.</dd></dl>
</li>
</ul>
<a name="nextElement()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextElement</h4>
<pre>public final&nbsp;java.lang.Object&nbsp;nextElement()</pre>
<div class="block">This method implements part of the java.util.Enumeration
 interface.  It is a wrapper for nextSolution.
 <p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>nextElement</code>&nbsp;in interface&nbsp;<code>java.util.Enumeration</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>A Hashtable representing a substitution.</dd></dl>
</li>
</ul>
<a name="rewind()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rewind</h4>
<pre>public final&nbsp;void&nbsp;rewind()</pre>
</li>
</ul>
<a name="close()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre>public final&nbsp;void&nbsp;close()</pre>
<div class="block">This method can be used to close an open query before its solutions are exhausted. 
 It is called automatically when solutions are exhausted, i.e. when hasMoreSolutions() fails.
 Calling close() on an already closed Query is harmless (has no effect).<p>
 
 Here is one way to get the first three solutions to a Query:
 <pre>
 Query q = new Query(predicate, args);
 Hashtable sub1 = (Hashtable) q.nextSolution();
 Hashtable sub2 = (Hashtable) q.nextSolution();
 Hashtable sub3 = (Hashtable) q.nextSolution();
 q.close();
 </pre><p></div>
</li>
</ul>
<a name="allSolutions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public final&nbsp;java.util.Hashtable[]&nbsp;allSolutions()</pre>
<div class="block">calls the Query's goal to exhaustion
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)
 <b>NB</b> in JPL 1.0.1, this method (inconsistently) returned null when a Query had no solutions;
 in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case,
 the quantity of solutions).<p>
 <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances;
 in JPL 2.x onwards they are keyed by the (String) names of variables,
 which is consistent with the Term type being just a concrete syntax for terms (and hence queries).<p></dd></dl>
</li>
</ul>
<a name="allSolutions(jpl.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;allSolutions(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query whose goal is the given Term,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="allSolutions(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;allSolutions(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="allSolutions(java.lang.String, jpl.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;allSolutions(java.lang.String&nbsp;text,
                                 <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This letter mode is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="nSolutions(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public final&nbsp;java.util.Hashtable[]&nbsp;nSolutions(long&nbsp;n)</pre>
<div class="block">calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an array of Hashtables (possibly none), each of which is a solution
 (in the order in which they were found) of the Query; at most 'n' solutions will be found and returned.
 <b>NB</b> in JPL 1.0.1, this method (inconsistently) returned null when a Query had no solutions;
 in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case,
 the quantity of solutions).<p>
 <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances;
 in JPL 2.x onwards they are keyed by the (String) names of variables,
 which is consistent with the Term type being just a concrete syntax for terms (and hence queries).<p></dd></dl>
</li>
</ul>
<a name="nSolutions(jpl.Term, long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;nSolutions(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal,
                               long&nbsp;n)</pre>
<div class="block">This static method creates a Query whose goal is the given Term,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="nSolutions(java.lang.String, long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;nSolutions(java.lang.String&nbsp;text,
                               long&nbsp;n)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd></dl>
</li>
</ul>
<a name="nSolutions(java.lang.String, jpl.Term[], long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Hashtable[]&nbsp;nSolutions(java.lang.String&nbsp;text,
                               <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params,
                               long&nbsp;n)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="oneSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public final&nbsp;java.util.Hashtable&nbsp;oneSolution()</pre>
<div class="block">Returns the first solution, if any, as a (possibly empty) Hashtable of variablename-to-term bindings, else null.
 
 This method will throw a JPLException if this Query is already open (and the Query will remain open as before).
 Otherwise, upon return, the Query will be closed.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the first solution, if the query has one, as a (possibly empty) Hashtable.
 If the return value is null, this means that the Query has no solutions.<p></dd></dl>
</li>
</ul>
<a name="oneSolution(jpl.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Hashtable&nbsp;oneSolution(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.
 The goal can be a jpl.Atom or a jpl.Compound, but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="oneSolution(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Hashtable&nbsp;oneSolution(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment,
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd></dl>
</li>
</ul>
<a name="oneSolution(java.lang.String, jpl.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Hashtable&nbsp;oneSolution(java.lang.String&nbsp;text,
                              <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its respective param
 to provide the goal of this query:
 the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Hashtable, else null.
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="query()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>query</h4>
<pre>public final&nbsp;boolean&nbsp;query()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Use .hasSolution() instead.</i></div>
<div class="block">This method will attempt to call this Query's goal within an available Prolog engine.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a JPLException if this Query is already open.</dd></dl>
</li>
</ul>
<a name="hasSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public final&nbsp;boolean&nbsp;hasSolution()</pre>
<div class="block">This method will attempt to call this Query's goal within an available Prolog engine.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a JPLException if this Query is already open.</dd></dl>
</li>
</ul>
<a name="hasSolution(jpl.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(<a href="../jpl/Term.html" title="class in jpl">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning true if a solution was found, else false.
 The goal can be a jpl.Atom or a jpl.Compound, but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="hasSolution(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text
 and calls it at most once, returning true if a solution was found, else false.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the goal of this Query, as Prolog source text</dd></dl>
</li>
</ul>
<a name="hasSolution(java.lang.String, jpl.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(java.lang.String&nbsp;text,
                  <a href="../jpl/Term.html" title="class in jpl">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its corresponding arg
 to provide the new Query's goal: the resulting Query is called as described above.
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of its goal and args are its args;
 it then calls this goal (at most once) and returns true if a solution was found, else false.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="abort()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>abort</h4>
<pre>public final&nbsp;int&nbsp;abort()</pre>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a crude String representation of a Query.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a crude String representation of a Query</dd></dl>
</li>
</ul>
<a name="debugString()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>debugString</h4>
<pre>public&nbsp;java.lang.String&nbsp;debugString()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i></i></div>
<div class="block">Returns a debug-friendly representation of a Query</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a debug-friendly representation of a Query</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../jpl/PrologException.html" title="class in jpl"><span class="strong">Prev Class</span></a></li>
<li><a href="../jpl/Term.html" title="class in jpl"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?jpl/Query.html" target="_top">Frames</a></li>
<li><a href="Query.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
